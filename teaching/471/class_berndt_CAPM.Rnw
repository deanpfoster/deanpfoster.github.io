\documentclass[14pt]{extarticle}


\renewcommand{\baselinestretch}{1.2}
% Deans New Commands
\usepackage[usenames]{color}
\definecolor{mypurple}{rgb}{.3,0,.5}
\newcommand{\dpf}[1]{\noindent{\textcolor{mypurple}{\{{\bf dpf:} \em #1\}}}}
\newcommand{\note}[1]{\noindent{\textcolor{red}{\{{\bf NOTE:} \em #1\}}}}
%\newcommand{\dpf}[1]{}
%\newcommand{\note}[1]{}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %                                                                          %
% %                                                                          %
% %                  B E G I N     D O C U M E N T                           %
% %                                                                          %
% %                                                                          %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\SweaveOpts{prefix.string=.figures/capm}
\title{CAPM: Berndt CAPM}
\author{Dean Foster}
\maketitle


\section{Admistrivia}

\begin{itemize}
\item Dice: who have done dice already?
\item It will take you about one hour (including a less than one page write up). 
\end{itemize}

\section{Story: Pair programming}
\begin{itemize}
\item Mythical man month
\item ``If you double the number of programmers the amount of time it
takes doubles.'' Huh?
\item Invention of {\em Extreme Programming.}  
\begin{itemize}
\item Always have working code
\item Always modify working code to make it simplier
\item Small changes and lots of testing
\end{itemize}
\item One Version is called {\em pair programming}
\begin{itemize}
\item Person who ``knows'' the code doesn't have the typewriter
\item Person who ``knows'' the code can only make suggestions
\item By the end of a day working together--the other person knows the code
\end{itemize}
\item Lots of experimental data on how effective pair programming is.
Not as many controlled experiments as there should be.  Oh well.
\end{itemize}

\section{Class notes}

\begin{itemize}
\item  variance / sd
\item variance vs covariance
\item Pictures
\item  variance formula for sums
\item covariance of x with x is variance of x
\end{itemize}

\section{CAPM without risk free}
\begin{itemize}
\item  eq (2.5) $r_p = \sum w_j r_j$
\item eq (2.6) variance formula
\item suppose $w_j$ is small.  In other words, consider adding a small amount to an existing portfolio
\item  how does r change
\item how does variance change
\item  if variances of two investments agree then r's must agree
\item  Better: if variance of a $\le$ variance of b, then return of a $\le$ return b
\item  But what if variances aren't equal?
\end{itemize}
\section{CAPM with risk free (scaling variances)}

\begin{itemize}
\item need to scale investments
\item need to sell (borrow) something to finance new investment
\item actual return is: $r_k -r_f$
\item Now we can scale to get marginal variances to match
\item  bingo: we have an equation describing returns vs marginal variance
\item $(r_k -r_f)/s_{kp}$ is constant for all possible investments
\item  a bounce per buck argument
\end{itemize}
\section{Using the market to set the constant}
\begin{itemize}
\item  equation holds if market
\item  generates CAPM equation (2.16)
\end{itemize}
\section{Doing statistics}
\begin{itemize}
\item  regression view of equation
\end{itemize}



\section*{Domino Sugar: a bootstrapping example}

Domino Sugar was one of the original 12 companies in the DOW.  So
let's track it over time to get a feel for what a long series looks
like.  This also removes most issues of selection bias since we could
only pick one company out of 12 total instead of 1 out of 5000 current
companies and then working backwards.

<<readdata, eval=TRUE, echo=TRUE>>=

#    ##########################################################
#    #
#    # Reading the files locally if you have them downloaded
#    #
#    ##########################################################
#
#    sugar <- read.csv("domino_sugar.csv");  
#    tbills <- read.csv("tbills-inflation.csv");  
#
#    ##########################################################
#    #
#    # Reading the web. 
#    #
#    ##########################################################

     sugar  <- read.csv("http://gosset.wharton.upenn.edu/~foster/teaching/471/domino_sugar.csv");  
     tbills <- read.csv("http://gosset.wharton.upenn.edu/~foster/teaching/471/tbills-inflation.csv");  

@ 
 
Now for some black magic: Let's merge these two data files together.
<<>>=

both <- merge(sugar,tbills,by.x="DATE",by.y="caldt")
sugar[1:10,]
tbills[1:10,]
both[1:10,]

@ 

Now to make up our variables:
<<>>=

# the following will list names.  It is useful for debugging
# names(Data)

time       <- both$DATE
market     <- both$vwretd       # dump leading missing value
riskfree   <- both$t30ret
domino     <- both$RET                # fix time scale, since 1981
cpi        <- both$cpiret
market.ex  <- market - riskfree
domino.ex  <- domino - riskfree

@ 

Classic CAPM plot:
<<echo=TRUE,fig=TRUE,width=4, height=4 >>=

 plot(domino.ex ~ market.ex)

@ 

Summary statistics:

<<echo=TRUE>>=

clean <- data.frame(time,  market = market.ex   ,  domino = domino.ex  ,  cpi)
clean <- clean[!(is.na(clean$domino)),]
clean <- clean[!(is.na(clean$market)),]

@ 
Portfolios:
<<echo=TRUE>>=

fraction <- .3
portfolio = fraction * clean$domino / mean(clean$domino) + (1 - fraction) * clean$market / mean(clean$market)
summary(portfolio)

@ 

Variance plot:
<<echo=TRUE>>=

fractions <- seq(-1 , 2 , .01);
mean.port <- 0 * fractions
var.port <- 0 * fractions                                                
for(i in 1:(length(fractions)))
  {
    portfolio = fractions[i] * clean$domino / mean(clean$domino) + (1 - fractions[i]) * clean$market / mean(clean$market)
    mean.port[i] <- mean(portfolio,na.rm=TRUE)
    var.port[i] <- var(portfolio,na.rm=TRUE)
  }

@ 


THe mean should be constant:


<<fig=TRUE,echo=TRUE,height=3, width=3>>=

  plot(fractions, mean.port,type="l")

@ 

(Example of white space rule!  This is a useless graph!)

Some variances are better than others:

\noindent
\hspace{-1.5in}
<<fig=TRUE,echo=TRUE,width=3,height=3>>=

  plot(fractions, var.port,type="l")

@ 

So our ``optimum'' is at:
<<echo=TRUE>>=

opt.fraction <- fractions[var.port == min(var.port)]
cat("Optimum point of original data: ", opt.fraction , "\n" );

@ 

But is the truely different than zero?  Let's use a bootstrap to tell.

<<echo=TRUE>>=

#####################################################################
#
# First define the parameters that will control our program
#
#####################################################################
fractions <- seq(-1 , 2 , .01);
repeats <- 100
num.rows <- dim(clean)[1]
#####################################################################
#
# Now say where we will put the output
#
#####################################################################
opt <- rep(0,repeats)
#####################################################################
#
# Time for our actual bootstrap loop
#
#####################################################################
for(j in 1:repeats)
{
    samples <- sample(1:num.rows,replace=TRUE)  # generate which rows to keep
    boot <- clean[samples,]                     # collect those rows into data.frame called boot
    #####################################################################
    #
    #   The following is the same we used before to compute the optimum
    #
    #####################################################################
    mean.port <- 0 * fractions
    var.port <- 0 * fractions
    for(i in 1:(length(fractions)))
     {
       portfolio <- fractions[i] * boot$domino/mean(boot$domino) + (1 - fractions[i]) * boot$market / mean(boot$market)
       mean.port[i] <- mean(portfolio,na.rm=TRUE)
       var.port[i] <- var(portfolio,na.rm=TRUE)
     }
    opt[j] = fractions[var.port == min(var.port)]  # Collect up the output
 }
@ 

Now we can see how much larger our bootstrap estimate is compared to
our "true" estimate.  This is the same relationship we expect our
estimator to have to the truth:
  
<<fig=TRUE>>=
hist(opt - opt.fraction)
@ 

\section*{Figuring out what the optimum actually is}

We can collect other statistics besides the optimum point. We could
also compute the alpha of the bootstrap regression.  Here is the exact
same code but now it collects up lots of other output.

<<echo=TRUE,fig=TRUE>>=

cat("Optimum point of original data: ",fractions[var.port == min(var.port)],"\n")
fractions <- seq(0 , 1.2 , .001);
repeats <- 100
results <- data.frame(row.names=1:100)
for(j in 1:repeats)
{
    samples <- sample(1:(dim(clean)[1]),replace=TRUE)
    mean.port <- 0 * fractions
    var.port <- 0 * fractions
    boot <- clean[samples,]
    for(i in 1:(length(fractions)))
     {
       portfolio <- fractions[i] * boot$domino/mean(boot$domino) + (1 - fractions[i]) * boot$market / mean(boot$market)
       mean.port[i] <- mean(portfolio,na.rm=TRUE)
       var.port[i] <- var(portfolio,na.rm=TRUE)
     }
  results$opt[[j]] = fractions[var.port == min(var.port)]
# Other statistics
  results$Vd[[j]] = var(boot$domino / mean(boot$domino))
  results$Vm[[j]] = var(boot$market / mean(boot$market))
  results$C[[j]] = cov(boot$domino / mean(boot$domino), boot$market / mean(boot$market))
 }
hist(results$opt)

@ 

Now we can play around with the results data.frame as much as we
like.  So the ``best'' column is an aproximation to what fraction you
should put into the stock.  This is seen by the following plot almost
being a straight line:
<<optBest,fig=TRUE>>=
# d(var.port)/d(fraction) = d(p^2 Vd + 2 C p (1-p) + (1-p)^2 VM)/dp
#                         = 2 p Vd + 2(1 - 2p) C  - 2(1-p) VM
#                       0 = 2 p Vd + 2 C - 4p C  - 2 Vm + 2 p Vm
#                       0 = 2p(Vd - 2 C + Vm) + 2(C - VM)
#                       p = (VM - C)/(VD - 2 C + VM)
results$best =  (results$Vm - results$C)/(results$Vd - 2 *results$C + results$Vm)

plot(results$opt ~ results$best)

@ 


\end{document}
